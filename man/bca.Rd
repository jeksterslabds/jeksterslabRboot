% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/boot_ci.R
\name{bca}
\alias{bca}
\title{Confidence Interval - Bias-Corrected and Accelerated}
\usage{
bca(
  thetahatstar,
  thetahat,
  data,
  fitFUN,
  ...,
  alpha = c(0.001, 0.01, 0.05),
  wald = FALSE,
  null = 0,
  dist = "z",
  df,
  eval = FALSE,
  theta = 0,
  par = TRUE,
  ncores = NULL,
  mc = TRUE,
  lb = FALSE,
  cl_eval = FALSE,
  cl_export = FALSE,
  cl_expr,
  cl_vars
)
}
\arguments{
\item{thetahatstar}{Numeric vector.
The bootstrap sampling distribution
\eqn{\left( \boldsymbol{\hat{\theta}^{*}} \right)},
that is,
the sampling distribution of \code{thetahat}
estimated for each \code{b} bootstrap sample.
\eqn{
    \hat{\theta}_{\left( 1 \right)},
    \hat{\theta}_{\left( 2 \right)},
    \hat{\theta}_{\left( 3 \right)},
    \hat{\theta}_{\left( b \right)},
    \dots,
    \hat{\theta}_{\left( B \right)}
  } .}

\item{thetahat}{Numeric.
Parameter estimate
\eqn{\left( \hat{\theta} \right)}
from the original sample data.}

\item{data}{Vector, matrix, or data frame.
Sample data.
Ignored if \code{thetahatstarjack}
is provided.}

\item{fitFUN}{Function.
Fit function to use on \code{data}.
The first argument should correspond to \code{data}.
Other arguments can be passed to \code{fitFUN}
using \code{...}.
\code{fitFUN} should return a single value.
Ignored if \code{thetahatstarjack}
is provided.}

\item{...}{Arguments to pass to \code{fitFUN}.}

\item{alpha}{Numeric vector.
Significance level
\eqn{\left( \alpha \right)} .
By default,
\code{alpha} is set to conventional
significance levels
\code{alpha = c(0.001, 0.01, 0.05)}.}

\item{wald}{Logical.
If \code{TRUE},
calculates the square root of the Wald test statistic and p-value.
The estimated bootstrap standard error is used.
The arguments
\code{null},
\code{dist},
and
\code{df}
are used to calculate
the square root of the Wald test statistic and p-value
and are NOT used in constructing the bootstrap confidence interval.
If \code{FALSE},
returns \code{statistic = NA}
and
\code{p = NA}
If \code{FALSE},
the arguments
\code{null},
\code{dist},
and
\code{df}
are ignored.}

\item{null}{Numeric.
Hypothesized value of \code{theta}
\eqn{\left( \theta_{0} \right)}.
Set to zero by default.}

\item{dist}{Character string.
\code{dist = "z"} for the standard normal distribution.
\code{dist = "t"} for the t distribution.}

\item{df}{Numeric.
Degrees of freedom (df) if \code{dist = "t"}.
Ignored if \code{dist = "z"}.}

\item{eval}{Logical.
Evaluate confidence intervals using
\code{\link[=zero_hit]{zero_hit()}},
\code{\link[=theta_hit]{theta_hit()}},
\code{\link[=len]{len()}},
and
\code{\link[=shape]{shape()}}.}

\item{theta}{Numeric.
Population parameter
\eqn{
  \left(
    \theta
  \right)
}.}

\item{par}{Logical.
If \code{TRUE}, use multiple cores.
If \code{FALSE}, use \code{\link[=lapply]{lapply()}}.}

\item{ncores}{Integer.
Number of cores to use if \code{par = TRUE}.
If unspecified, defaults to \code{detectCores() - 1}.}

\item{mc}{Logical.
If \code{TRUE}, use \code{\link[parallel:mclapply]{parallel::mclapply()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}} or \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
Ignored if \code{par = FALSE}.}

\item{lb}{Logical.
If \code{TRUE} use \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}}.
Ignored if \code{par = FALSE} and \code{mc = TRUE}.}

\item{cl_eval}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}} using \code{cl_expr}.
Ignored if \code{mc = TRUE}.}

\item{cl_export}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterExport()}} using \code{cl_vars}.
Ignored if \code{mc = TRUE}.}

\item{cl_expr}{Expression.
Expression passed to \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}}
Ignored if \code{mc = TRUE}.}

\item{cl_vars}{Character vector.
Names of objects to pass to \code{\link[parallel:clusterApply]{parallel::clusterExport()}}
Ignored if \code{mc = TRUE}.}
}
\value{
Returns a vector with the following elements:
\describe{
\item{statistic}{Square root of Wald test statistic. \code{NA} if \code{wald = FALSE}.}
\item{p}{p-value. \code{NA} if \code{wald = FALSE}.}
\item{se}{Estimated bootstrap standard error \eqn{\left( \widehat{\mathrm{se}}_{\mathrm{B}} \left( \hat{\theta} \right) \right)}.}
\item{ci_}{Estimated bias-corrected and accelerated confidence limits corresponding to alpha from the bootstrap sampling distribution thetahatstar \eqn{\left( \boldsymbol{\hat{\theta}^{*}} \right)}.}
}
If \code{eval = TRUE},
appends the following to the results vector
\describe{
\item{zero_hit_}{Logical. Tests if confidence interval contains zero.}
\item{theta_hit_}{Logical. Tests if confidence interval contains theta.}
\item{length_}{Length of confidence interval.}
\item{shape_}{Shape of confidence interval.}
}
}
\description{
Calculates bias-corrected and accelerated confidence intervals.
}
\details{
The estimated bootstrap standard error
is given by
\deqn{
  \widehat{\mathrm{se}}_{\mathrm{B}}
  \left(
    \hat{\theta}
  \right)
  =
  \sqrt{
    \frac{1}{B - 1}
    \sum_{b = 1}^{B}
    \left[
      \hat{\theta}^{*} \left( b \right)
      -
      \hat{\theta}^{*} \left( \cdot \right)
    \right]^2
  }
}
where
\deqn{
  \hat{\theta}^{*}
  \left(
    \cdot
  \right)
  =
  \frac{1}{B}
  \sum_{b = 1}^{B}
  \hat{\theta}^{*} \left( b \right) .
}

In addition to the bias-correction
\eqn{\hat{z}_{0}}
discussed in \code{\link[=bc]{bc()}},
the acceleration
\eqn{\hat{a}},
which refers to the rate of change
of the standard error of
\eqn{\hat{\theta}}
with respect to the true parameter value
\eqn{\theta},
is factored in.

The acceleration \eqn{\hat{a}}
is given by

\deqn{
  \hat{a}
  =
  \frac{
    \sum_{i = 1}^{n}
    \left[
      \hat{\theta}_{
        \left(
          \cdot
        \right)
      }
      -
      \hat{\theta}_{
        \left(
          i
        \right)
      }
    \right]^{3}
  }
  {
    6
    \left\{
      \sum_{i = 1}^{n}
      \left[
        \hat{\theta}_{
          \left(
            \cdot
          \right)
        }
        -
        \hat{\theta}_{
          \left(
            i
          \right)}
      \right]^{2}
    \right\}^{3/2}
  }
}
where
\deqn{
  \hat{\theta}_{
    \left(
      i
    \right)
  }
  =
  \left\{
    \hat{\theta}_{\left( 1 \right)},
    \hat{\theta}_{\left( 2 \right)},
    \hat{\theta}_{\left( 3 \right)},
    \dots,
    \hat{\theta}_{\left( n \right)}
  \right\}
}
is the jackknife sampling distribution
and
\deqn{
  \hat{\theta}_{
    \left(
      \cdot
    \right)
  }
  =
  \frac{1}{n}
  \sum_{i = 1}^{n}
  \hat{\theta}_{
    \left(
      i
    \right)
  }
}
is the jackknife mean.
See
\code{\link[=jack]{jack()}}
and
\code{\link[=jack_hat]{jack_hat()}} .

Using
\eqn{\hat{z}_{0}}
and
\eqn{\hat{a}}
we can obtain the adjusted \eqn{z}-scores as follows

\deqn{
  z_{
    \mathrm{BCa}_{\mathrm{lo}}
  }
  =
  \hat{z}_{0}
  +
  \frac{
    \hat{z}_{0}
    +
    z_{
      \left(
        \frac{
          \alpha
        }
        {
          2
        }
      \right)
    }
  }
  {
    1
    -
    \hat{a}
    \left[
      \hat{z}_{0}
      +
      z_{
        \left(
          \frac{
            \alpha
          }
          {
            2
          }
        \right)
      }
    \right]
  } ,
}

\deqn{
  z_{
    \mathrm{BCa}_{\mathrm{up}}
  }
  =
  \hat{z}_{0}
  +
  \frac{
    \hat{z}_{0}
    +
    z_{
      \left[
        1
        -
        \frac{
          \alpha
        }
        {
          2
        }
      \right]
    }
  }
  {
    1
    -
    \hat{a}
    \left[
      \hat{z}_{0}
      +
      z_{
        \left(
          1
          -
          \frac{
            \alpha
          }
          {
            2
          }
        \right)
      }
    \right]
  } .
}

The adjusted \eqn{z}-scores
are used to determine the adjusted
percentile ranks
to form the confidence interval.

The bias-corrected and accelerated confidence interval is given by
\deqn{
  \left[
    \hat{\theta}_{\mathrm{lo}},
    \hat{\theta}_{\mathrm{up}}
  \right]
  =
  \left[
    \hat{\theta}^{*}_{
      \left(
        z_{
          \mathrm{BCa}_{
            \mathrm{lo}
          }
        }
      \right)
    },
    \hat{\theta}^{*}_{
      \left(
        z_{
          \mathrm{BCa}_{
            \mathrm{up}
          }
        }
      \right)
    }
  \right] .
}

For more details and examples see the following vignettes:

\href{https://jeksterslabds.github.io/jeksterslabRboot/articles/notes/notes_intro_nb.html}{Notes: Introduction to Nonparametric Bootstrapping}

\href{https://jeksterslabds.github.io/jeksterslabRboot/articles/notes/notes_intro_pb.html}{Notes: Introduction to Parametric Bootstrapping}
}
\references{
Efron, B., & Tibshirani, R. J. (1993).
\emph{An introduction to the bootstrap}.
New York, N.Y: Chapman & Hall.
}
\seealso{
Other bootstrap confidence interval functions: 
\code{\link{.bca}()},
\code{\link{bc}()},
\code{\link{pc}()}
}
\author{
Ivan Jacob Agaloos Pesigan
}
\concept{bootstrap confidence interval functions}
\keyword{confidence}
\keyword{interval}
